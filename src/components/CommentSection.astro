---
// filepath: /home/mostafa/Documents/Mostafa/Software/Projects/gemvoyage-astro/src/components/CommentSection.astro
import AuthorInfo from './AuthorInfo.astro';
import { API_BASE_URL } from '../lib/apiConfig';

interface Props {
  gemId: string;
  initialComments?: any[];
}

const { gemId, initialComments = [] } = Astro.props;

// Fetch comments server-side
let comments = initialComments;
try {
  const res = await fetch(`${API_BASE_URL}/gem_comment/gem/${gemId}`);
  if (res.ok) {
    comments = await res.json();
  }
} catch (error) {
  console.error('Failed to fetch comments:', error);
}
---
<div class="mt-8">
  <h3 class="text-xl font-bold mb-6">
    Comments (<span id="comment-count">{comments.length}</span>)
  </h3>
  
  <form id="comment-form" class="mb-8">
    <div class="flex gap-4">
      <div class="flex h-10 w-10 shrink-0 overflow-hidden rounded-full">
        <img src="https://i.pravatar.cc/150" alt="Your avatar" class="aspect-square h-full w-full" />
      </div>
      <div class="flex-1">
        <textarea 
          id="comment-textarea"
          placeholder="Share your thoughts about this gem..." 
          class="flex min-h-[100px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 mb-3"
        ></textarea>
        <div class="flex justify-end">
          <button 
            type="submit" 
            class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-gem-300 hover:bg-gem-400 h-10 px-4 py-2"
            id="submit-btn"
          >
            Post Comment
          </button>
        </div>
      </div>
    </div>
  </form>
  
  <div id="comments-container" class="space-y-6">
    {comments.map((comment) => (
      <div id={comment.id} class="rounded-lg border p-4 animate-fade-in">
        <div class="flex justify-between">
          <div class="flex items-center gap-3">
            <div>
              <p class="font-medium text-sm">
                <AuthorInfo id={comment.ownerId} />
              </p>
              <p class="text-xs text-muted-foreground">
                {new Intl.RelativeTimeFormat('en', { numeric: 'auto' }).format(
                  Math.floor((new Date(comment.createdAt).getTime() - Date.now()) / (1000 * 60 * 60 * 24)), 
                  'day'
                )}
              </p>
            </div>
          </div>
        </div>
        
        <div class="mt-3">
          <p class="text-sm">{comment.comment}</p>
        </div>
      </div>
    ))}
  </div>
</div>

<script define:vars={{ gemId, API_BASE_URL }}>
  const form = document.getElementById('comment-form');
  const textarea = document.getElementById('comment-textarea');
  const submitBtn = document.getElementById('submit-btn');
  const commentsContainer = document.getElementById('comments-container');
  const commentCount = document.getElementById('comment-count');

  function showToast(title, description, variant = 'default') {
    // Simple toast implementation - you can integrate with your toast system
    console.log(`${title}: ${description}`);
  }

  function formatDistanceToNow(date) {
    const now = new Date();
    const diffInSeconds = Math.floor((now - date) / 1000);
    
    if (diffInSeconds < 60) return 'just now';
    if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)} minutes ago`;
    if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)} hours ago`;
    return `${Math.floor(diffInSeconds / 86400)} days ago`;
  }

  async function loadComments() {
    try {
      const res = await fetch(`${API_BASE_URL}/gem_comment/gem/${gemId}`);
      if (!res.ok) throw new Error('Failed to fetch comments');
      const comments = await res.json();
      
      commentsContainer.innerHTML = comments.map(comment => `
        <div class="rounded-lg border p-4 animate-fade-in">
          <div class="flex justify-between">
            <div class="flex items-center gap-3">
              <div>
                <p class="font-medium text-sm">User ${comment.ownerId}</p>
                <p class="text-xs text-muted-foreground">
                  ${formatDistanceToNow(new Date(comment.createdAt))}
                </p>
              </div>
            </div>
          </div>
          <div class="mt-3">
            <p class="text-sm">${comment.comment}</p>
          </div>
        </div>
      `).join('');
      
      commentCount.textContent = comments.length;
    } catch (error) {
      showToast('Error', 'Failed to fetch comments.', 'destructive');
    }
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const commentText = textarea.value.trim();
    if (!commentText) return;
    
    const userId = localStorage.getItem('userId');
    if (!userId) {
      showToast('Error', 'You must be logged in to comment.', 'destructive');
      return;
    }

    const newComment = {
      id: crypto.randomUUID(),
      createdAt: new Date().toISOString(),
      gemId,
      ownerId: userId,
      comment: commentText,
    };

    try {
      submitBtn.disabled = true;
      
      const res = await fetch(`${API_BASE_URL}/gem_comment`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newComment),
      });
      
      if (!res.ok) {
        showToast('Error', 'Failed to post comment.', 'destructive');
        return;
      }
      
      await loadComments();
      textarea.value = '';
      showToast('Success', 'Comment posted!', 'default');
    } catch (error) {
      showToast('Error', 'Failed to post comment.', 'destructive');
    } finally {
      submitBtn.disabled = false;
    }
  });

  textarea.addEventListener('input', () => {
    submitBtn.disabled = !textarea.value.trim();
  });
</script>